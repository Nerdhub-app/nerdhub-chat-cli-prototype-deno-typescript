import { assert, assertEquals, assertRejects } from "@std/assert";
import { describe, it } from "@std/testing/bdd";
import ConcreteRouter, {
  UnmatchedRequestThroughEntriesError,
} from "./router.ts";
import ConcreteRouterRequest from "./router-request.ts";
import { ConcreteRouterResponse } from "./router-response.ts";
import { type Spy, spy } from "@std/testing/mock";
import type {
  GenericRequestErrorHandler,
  GenericRequestProcessingHandler,
  GenericRouterRequest,
  HttpMethod,
  RequestHandlerNextFunction,
  RouterResponse,
} from "./router.core.d.ts";

/**
 * A helper that wraps spy and preserves the function length.
 * The router uses function length to distinguish between processing and error handlers.
 */
function spyWithLength<
  Self,
  Args extends unknown[],
  Return,
>(
  fn: (this: Self, ...args: Args) => Return,
): Spy<Self, Args, Return> {
  const s = spy(fn);
  Object.defineProperty(s, "length", { value: fn.length });
  return s;
}

describe("ConcreteRouter", () => {
  const noopHandler: GenericRequestProcessingHandler = () => Promise.resolve();
  const noopErrorHandler: GenericRequestErrorHandler = (
    _err,
    _req,
    _res,
    _next,
  ) => Promise.resolve();

  const createMockRequest = (
    method: HttpMethod,
    url: string = "http://localhost/",
    body: unknown = null,
  ) => {
    return new ConcreteRouterRequest({
      _request: new Request(url, { method }),
      query: Object.fromEntries(new URL(url).searchParams),
      context: {},
      body,
    });
  };

  const createMockResponse = () => new ConcreteRouterResponse();

  it("should throw UnmatchedRequestThroughEntriesError if no handlers match", async () => {
    const router = new ConcreteRouter();
    router.get("/foo", () => Promise.resolve("ok"));

    const req = createMockRequest("GET", "http://localhost/bar");
    const res = createMockResponse();

    await assertRejects(
      () => router.channelRequestThroughRequestHandlers(req, res),
      UnmatchedRequestThroughEntriesError,
    );
  });

  describe("use", () => {
    it("should register a request processing handler for any method and path", () => {
      const router = new ConcreteRouter();
      router.use(noopHandler);

      const entries = router.requestHandlersEntries;
      assertEquals(entries.length, 1);
      assertEquals(entries[0].isErrorHandler, false);
      // @ts-ignore: checking specific property for testing
      assertEquals(entries[0].method, null);
      // @ts-ignore: checking specific property for testing
      assertEquals(entries[0].pathnameData, null);
    });

    it("should register a request processing handler for a specific path", () => {
      const router = new ConcreteRouter();
      router.use("/test", noopHandler);

      const entries = router.requestHandlersEntries;
      assertEquals(entries.length, 1);
      assertEquals(entries[0].isErrorHandler, false);
      // @ts-ignore: checking specific property for testing
      assertEquals(entries[0].pathnameData?.value, "test");
    });

    it("should register an error handler", () => {
      const router = new ConcreteRouter();
      router.use(noopErrorHandler);

      const entries = router.requestHandlersEntries;
      assertEquals(entries.length, 1);
      assertEquals(entries[0].isErrorHandler, true);
    });

    it("should register a sub-router", () => {
      const router = new ConcreteRouter();
      const subRouter = new ConcreteRouter();
      router.use("/api", subRouter);

      const entries = router.requestHandlersEntries;
      assertEquals(entries.length, 1);
      // @ts-ignore: checking internal property
      assertEquals(entries[0].handlers[0], subRouter);
    });

    it("should correctly generate regex pattern and params types for paths with parameters", () => {
      const router = new ConcreteRouter();
      router.use("/users/:id/posts/:postId", noopHandler);

      const entries = router.requestHandlersEntries;
      // @ts-ignore: checking internal property
      const pathnameData = entries[0].pathnameData;

      // regex for /users/:id/posts/:postId -> ^users/(?<id>[a-zA-Z0-9+=*&_-]+)/posts/(?<postId>[a-zA-Z0-9+=*&_-]+)$
      // Note: check the exact regex generated by `getRoutePathnameRegExpPattern` implementation if needed,
      // but assuming standard implementation from `router.core.utils.ts`

      assert(pathnameData !== null);
      assert(pathnameData.regExpPattern.includes("(?<id>"));
      assert(pathnameData.regExpPattern.includes("(?<postId>"));

      assertEquals(pathnameData.paramsTypes, {
        id: "param",
        postId: "param",
      });
    });

    it("should correctly generate regex pattern and params types for paths with wildcards", () => {
      const router = new ConcreteRouter();
      router.use("/files/*{path}", noopHandler);

      const entries = router.requestHandlersEntries;
      // @ts-ignore: checking internal property
      const pathnameData = entries[0].pathnameData;

      assert(pathnameData !== null);
      assert(pathnameData.regExpPattern.includes("(?<path>"));
      // Wildcard regex usually differs slightly

      assertEquals(pathnameData.paramsTypes, {
        path: "wildcard",
      });
    });
  });

  const methods = ["get", "post", "put", "patch", "delete"] as const;

  methods.forEach((method) => {
    describe(method, () => {
      it(`should register a ${method.toUpperCase()} handler with path`, () => {
        const router = new ConcreteRouter();
        router[method]("/test", noopHandler);

        const entries = router.requestHandlersEntries;
        assertEquals(entries.length, 1);
        assertEquals(entries[0].isErrorHandler, false);
        // @ts-ignore: checking specific property for testing
        assertEquals(entries[0].method, method.toUpperCase());
        // @ts-ignore: checking specific property for testing
        assertEquals(entries[0].pathnameData?.value, "test");
      });

      it(`should register a ${method.toUpperCase()} handler without path (implied root/wildcard match logic depending on impl but here checking null path data if supported or default behavior)`, () => {
        // The implementation of get/post/etc supports optional path?
        // Looking at signatures:
        // get(...args: | RequestProcessingHandlersEntryParams | [string, ...RequestProcessingHandlersEntryParams]): void
        // So yes, it supports calling without string path as first arg.

        const router = new ConcreteRouter();
        router[method](noopHandler);

        const entries = router.requestHandlersEntries;
        assertEquals(entries.length, 1);
        assertEquals(entries[0].isErrorHandler, false);
        // @ts-ignore: checking specific property for testing
        assertEquals(entries[0].method, method.toUpperCase());
        // @ts-ignore: checking specific property for testing
        assertEquals(entries[0].pathnameData, null);
      });

      it("should correctly generate regex pattern and params types for paths with parameters", () => {
        const router = new ConcreteRouter();
        router[method]("/users/:id/posts/:postId", noopHandler);

        const entries = router.requestHandlersEntries;
        // @ts-ignore: checking internal property
        const pathnameData = entries[0].pathnameData;

        // regex for /users/:id/posts/:postId -> ^users/(?<id>[a-zA-Z0-9+=*&_-]+)/posts/(?<postId>[a-zA-Z0-9+=*&_-]+)$
        // Note: check the exact regex generated by `getRoutePathnameRegExpPattern` implementation if needed,
        // but assuming standard implementation from `router.core.utils.ts`

        assert(pathnameData !== null);
        assert(pathnameData.regExpPattern.includes("(?<id>"));
        assert(pathnameData.regExpPattern.includes("(?<postId>"));

        assertEquals(pathnameData.paramsTypes, {
          id: "param",
          postId: "param",
        });
      });

      it("should correctly generate regex pattern and params types for paths with wildcards", () => {
        const router = new ConcreteRouter();
        router[method]("/files/*{path}", noopHandler);

        const entries = router.requestHandlersEntries;
        // @ts-ignore: checking internal property
        const pathnameData = entries[0].pathnameData;

        assert(pathnameData !== null);
        assert(pathnameData.regExpPattern.includes("(?<path>"));
        // Wildcard regex usually differs slightly

        assertEquals(pathnameData.paramsTypes, {
          path: "wildcard",
        });
      });
    });
  });

  describe("Multiple request handlers entries", () => {
    it("should register multiple handlers", () => {
      const router = new ConcreteRouter();
      router.use(noopHandler);
      router.get("/test", noopHandler);
      router.post("/api", noopHandler);

      const entries = router.requestHandlersEntries;
      assertEquals(entries.length, 3);
      // @ts-ignore: checking internal property
      assertEquals(entries[0].method, null);
      // @ts-ignore: checking internal property
      assertEquals(entries[1].method, "GET");
      // @ts-ignore: checking internal property
      assertEquals(entries[2].method, "POST");
    });
  });

  describe("channelRequestThroughRequestHandlers", () => {
    it("should invoke a handler registered with use() without pathname", async () => {
      const router = new ConcreteRouter();
      const handlerSpy = spyWithLength(() => Promise.resolve("ok"));
      router.use(handlerSpy);

      const req = createMockRequest("GET");
      const res = createMockResponse();
      const result = await router.channelRequestThroughRequestHandlers(
        req,
        res,
      );

      assertEquals(result, "ok");
      assertEquals(handlerSpy.calls.length, 1);
    });

    it("should invoke a handler registered with use() with a matching pathname", async () => {
      const router = new ConcreteRouter();
      const handlerSpy = spyWithLength(() => Promise.resolve("ok"));
      router.use("/test", handlerSpy);

      const req = createMockRequest("GET", "http://localhost/test");
      const res = createMockResponse();
      const result = await router.channelRequestThroughRequestHandlers(
        req,
        res,
      );

      assertEquals(result, "ok");
      assertEquals(handlerSpy.calls.length, 1);
    });

    it("should forward to the next handler when next() is called", async () => {
      const router = new ConcreteRouter();
      const handler1 = spyWithLength(
        (
          _req: GenericRouterRequest,
          _res: RouterResponse,
          next?: RequestHandlerNextFunction,
        ) => {
          next!();
          return Promise.resolve();
        },
      );
      const handler2 = spyWithLength(() => Promise.resolve("finished"));
      router.use(handler1, handler2);

      const req = createMockRequest("GET");
      const res = createMockResponse();
      const result = await router.channelRequestThroughRequestHandlers(
        req,
        res,
      );

      assertEquals(result, "finished");
      assertEquals(handler1.calls.length, 1);
      assertEquals(handler2.calls.length, 1);
    });

    it("should invoke handlers from multiple entries sequentially", async () => {
      const router = new ConcreteRouter();
      const handler1 = spyWithLength(
        (
          _req: GenericRouterRequest,
          _res: RouterResponse,
          next?: RequestHandlerNextFunction,
        ) => {
          next!();
          return Promise.resolve();
        },
      );
      const handler2 = spyWithLength(() => Promise.resolve("done"));
      router.use(handler1);
      router.use(handler2);

      const req = createMockRequest("GET");
      const res = createMockResponse();
      const result = await router.channelRequestThroughRequestHandlers(
        req,
        res,
      );

      assertEquals(result, "done");
      assertEquals(handler1.calls.length, 1);
      assertEquals(handler2.calls.length, 1);
    });

    it("should match pathnames correctly and skip non-matching ones", async () => {
      const router = new ConcreteRouter();
      const handler1 = spyWithLength(
        (
          _req: GenericRouterRequest,
          _res: RouterResponse,
          next?: RequestHandlerNextFunction,
        ) => {
          next!();
          return Promise.resolve();
        },
      );
      const handler2 = spyWithLength(
        (
          _req: GenericRouterRequest,
          _res: RouterResponse,
          next?: RequestHandlerNextFunction,
        ) => {
          next!();
          return Promise.resolve();
        },
      ); // Should be skipped
      const handler3 = spyWithLength(() => Promise.resolve("matched"));

      router.use("/foo", handler1);
      router.use("/products", handler2);
      router.use("/foo/*{params}", handler3);

      const req = createMockRequest("GET", "http://localhost/foo");
      const res = createMockResponse();
      const result = await router.channelRequestThroughRequestHandlers(
        req,
        res,
      );

      assertEquals(result, "matched");
      assertEquals(handler1.calls.length, 1);
      assertEquals(handler2.calls.length, 0);
      assertEquals(handler3.calls.length, 1);
    });

    it("should propagate errors to the next error handler", async () => {
      const router = new ConcreteRouter();
      const error = new Error("oops");
      const handler1 = spyWithLength(
        (
          _req: GenericRouterRequest,
          _res: RouterResponse,
          next?: RequestHandlerNextFunction,
        ) => {
          next!(error);
          return Promise.resolve();
        },
      );
      const handler2 = spyWithLength(
        (
          _req: GenericRouterRequest,
          _res: RouterResponse,
          next?: RequestHandlerNextFunction,
        ) => {
          next!();
          return Promise.resolve();
        },
      ); // Should be skipped
      const errorHandler = spyWithLength(
        (
          err: unknown,
          _req: GenericRouterRequest,
          _res: RouterResponse,
          _next: RequestHandlerNextFunction,
        ) => {
          assertEquals(err, error);
          return Promise.resolve("error-handled");
        },
      );

      router.use(handler1);
      router.use(handler2);
      router.use(errorHandler);

      const req = createMockRequest("GET");
      const res = createMockResponse();
      const result = await router.channelRequestThroughRequestHandlers(
        req,
        res,
      );

      assertEquals(result, "error-handled");
      assertEquals(handler1.calls.length, 1);
      assertEquals(handler2.calls.length, 0);
      assertEquals(errorHandler.calls.length, 1);
    });

    it("should invoke the correct handler for each HTTP verb", async () => {
      const verbs = ["GET", "POST", "PUT", "PATCH", "DELETE"] as const;

      for (const verb of verbs) {
        const router = new ConcreteRouter();
        const handlerSpy = spyWithLength(() => Promise.resolve(verb));
        router[verb.toLowerCase() as Lowercase<HttpMethod>](
          "/test",
          handlerSpy,
        );

        const req = createMockRequest(verb, "http://localhost/test");
        const res = createMockResponse();
        const result = await router.channelRequestThroughRequestHandlers(
          req,
          res,
        );
        assertEquals(result, verb);
        assertEquals(handlerSpy.calls.length, 1);
      }
    });

    it("should prioritize exact matches over wildcards when both match", async () => {
      // Actually the order of registration matters in most routers.
      // "the first 2 entries' paths are different and the last one is straight wildcard like /*{any}, the request should only invoke the request handler under the widlcard route."
      // If none of the first two match, it falls back to wildcard.
      const router = new ConcreteRouter();
      const h1 = spyWithLength(() => Promise.resolve("h1"));
      const h2 = spyWithLength(() => Promise.resolve("h2"));
      const hWildcard = spyWithLength(() => Promise.resolve("wildcard"));

      router.get("/foo", h1);
      router.get("/bar", h2);
      router.get("/*{any}", hWildcard);

      const req = createMockRequest("GET", "http://localhost/baz");
      const res = createMockResponse();
      const result = await router.channelRequestThroughRequestHandlers(
        req,
        res,
      );

      assertEquals(result, "wildcard");
      assertEquals(h1.calls.length, 0);
      assertEquals(h2.calls.length, 0);
      assertEquals(hWildcard.calls.length, 1);
    });

    describe("Sub-routing", () => {
      it("should invoke sub-router handler registered without pathname", async () => {
        const parentRouter = new ConcreteRouter();
        const subRouter = new ConcreteRouter();
        const handler = spyWithLength(() => Promise.resolve("sub-ok"));
        subRouter.use(handler);
        parentRouter.use("/foo", subRouter);

        const req = createMockRequest("GET", "http://localhost/foo/bar");
        const res = createMockResponse();
        const result = await parentRouter.channelRequestThroughRequestHandlers(
          req,
          res,
        );

        assertEquals(result, "sub-ok");
        assertEquals(handler.calls.length, 1);
      });

      it("should match index pathname '/' and empty pathname '' correctly in sub-router", async () => {
        const parentRouter = new ConcreteRouter();
        const subRouter = new ConcreteRouter();
        const h1 = spyWithLength(
          (
            _req: GenericRouterRequest,
            _res: RouterResponse,
            next?: RequestHandlerNextFunction,
          ) => {
            next!();
            return Promise.resolve();
          },
        );
        const h2 = spyWithLength(() => Promise.resolve("at-root"));

        subRouter.use("/", h1);
        subRouter.use("", h2);
        parentRouter.use("/foo", subRouter);

        const req = createMockRequest("GET", "http://localhost/foo");
        const res = createMockResponse();
        await parentRouter.channelRequestThroughRequestHandlers(req, res);

        assertEquals(h1.calls.length, 1);
        assertEquals(h2.calls.length, 1);
      });

      it("should handle '/bar' and 'bar' pathnames correctly in sub-router", async () => {
        const parentRouter = new ConcreteRouter();
        const subRouter = new ConcreteRouter();
        const h1 = spyWithLength(
          (
            _req: GenericRouterRequest,
            _res: RouterResponse,
            next?: RequestHandlerNextFunction,
          ) => {
            next!();
            return Promise.resolve();
          },
        );
        const h2 = spyWithLength(() => Promise.resolve("at-bar"));

        subRouter.use("/bar", h1);
        subRouter.use("bar", h2);
        parentRouter.use("/foo", subRouter);

        const req = createMockRequest("GET", "http://localhost/foo/bar");
        const res = createMockResponse();
        await parentRouter.channelRequestThroughRequestHandlers(req, res);

        assertEquals(h1.calls.length, 1);
        assertEquals(h2.calls.length, 1);
      });

      it("should handle parameters correctly in sub-router with '/:id' and ':id'", async () => {
        const parentRouter = new ConcreteRouter();
        const subRouter = new ConcreteRouter();
        const h1 = spyWithLength(
          (
            _req: GenericRouterRequest,
            _res: RouterResponse,
            next?: RequestHandlerNextFunction,
          ) => {
            next!();
            return Promise.resolve();
          },
        );
        const h2 = spyWithLength(() => Promise.resolve("at-id"));

        subRouter.use("/:id", h1);
        subRouter.use(":id", h2);
        parentRouter.use("/foo", subRouter);

        const req = createMockRequest("GET", "http://localhost/foo/123");
        const res = createMockResponse();
        await parentRouter.channelRequestThroughRequestHandlers(req, res);

        assertEquals(h1.calls.length, 1);
        assertEquals(h2.calls.length, 1);
        assertEquals(req.params.id, "123");
      });

      it("should handle wildcards correctly in sub-router with '/*{any}' and '*{any}'", async () => {
        const parentRouter = new ConcreteRouter();
        const subRouter = new ConcreteRouter();
        const h1 = spyWithLength(
          (
            _req: GenericRouterRequest,
            _res: RouterResponse,
            next?: RequestHandlerNextFunction,
          ) => {
            next!();
            return Promise.resolve();
          },
        );
        const h2 = spyWithLength(() => Promise.resolve("at-wildcard"));

        subRouter.use("/*{any}", h1);
        subRouter.use("*{any}", h2);
        parentRouter.use("/foo", subRouter);

        const req = createMockRequest("GET", "http://localhost/foo/a/b/c");
        const res = createMockResponse();
        await parentRouter.channelRequestThroughRequestHandlers(req, res);

        assertEquals(h1.calls.length, 1);
        assertEquals(h2.calls.length, 1);
        assertEquals(req.params.any, ["a", "b", "c"]);
      });

      it("should fallback to parent wildcard if sub-router does not match", async () => {
        const parentRouter = new ConcreteRouter();
        const subRouter = new ConcreteRouter();
        const subHandler = spyWithLength(() => Promise.resolve("sub"));
        const parentFallback = spyWithLength(() => Promise.resolve("fallback"));

        subRouter.get("/bar", subHandler);
        parentRouter.use("/foo", subRouter);
        parentRouter.use("/*{any}", parentFallback);

        const req = createMockRequest("GET", "http://localhost/other");
        const res = createMockResponse();
        const result = await parentRouter.channelRequestThroughRequestHandlers(
          req,
          res,
        );

        assertEquals(result, "fallback");
        assertEquals(subHandler.calls.length, 0);
        assertEquals(parentFallback.calls.length, 1);
      });
    });

    describe("Request Parameters", () => {
      it("should extract simple parameters correctly", async () => {
        const router = new ConcreteRouter();
        const handler = spyWithLength(() => Promise.resolve("ok"));
        router.get("/foo/:id", handler);

        const req = createMockRequest("GET", "http://localhost/foo/123");
        await router.channelRequestThroughRequestHandlers(
          req,
          createMockResponse(),
        );

        assertEquals(handler.calls.length, 1);
        assertEquals(req.params.id, "123");
      });

      it("should extract empty wildcard parameters correctly", async () => {
        const router = new ConcreteRouter();
        const handler = spyWithLength(() => Promise.resolve("ok"));
        router.get("/foo/*{any}", handler);

        const req = createMockRequest("GET", "http://localhost/foo");
        await router.channelRequestThroughRequestHandlers(
          req,
          createMockResponse(),
        );

        assertEquals(handler.calls.length, 1);
        assertEquals(req.params.any, []);
      });

      it("should extract single-level wildcard parameters correctly", async () => {
        const router = new ConcreteRouter();
        const handler = spyWithLength(() => Promise.resolve("ok"));
        router.get("/foo/*{any}", handler);

        const req = createMockRequest("GET", "http://localhost/foo/123");
        await router.channelRequestThroughRequestHandlers(
          req,
          createMockResponse(),
        );

        assertEquals(req.params.any, ["123"]);
      });

      it("should extract multi-level wildcard parameters correctly", async () => {
        const router = new ConcreteRouter();
        const handler = spyWithLength(() => Promise.resolve("ok"));
        router.get("/foo/*{any}", handler);

        const req = createMockRequest("GET", "http://localhost/foo/123/bar");
        await router.channelRequestThroughRequestHandlers(
          req,
          createMockResponse(),
        );

        assertEquals(req.params.any, ["123", "bar"]);
      });

      it("should extract mixed parameters and wildcards correctly", async () => {
        const router = new ConcreteRouter();
        const handler = spyWithLength(() => Promise.resolve("ok"));
        router.get("/foo/:id/bar/:slug/*{any}", handler);

        const req = createMockRequest(
          "GET",
          "http://localhost/foo/123/bar/456/what/how",
        );
        await router.channelRequestThroughRequestHandlers(
          req,
          createMockResponse(),
        );

        assertEquals(req.params, {
          id: "123",
          slug: "456",
          any: ["what", "how"],
        } as Record<string, unknown>);
      });

      it("should merge parameters correctly from sub-router", async () => {
        const parentRouter = new ConcreteRouter();
        const subRouter = new ConcreteRouter();
        const handler = spyWithLength(() => Promise.resolve("ok"));

        subRouter.get("/:slug/*{any}", handler);
        parentRouter.use("/foo/:id/bar", subRouter);

        const req = createMockRequest(
          "GET",
          "http://localhost/foo/123/bar/456/what/how",
        );
        await parentRouter.channelRequestThroughRequestHandlers(
          req,
          createMockResponse(),
        );

        assertEquals(req.params, {
          id: "123",
          slug: "456",
          any: ["what", "how"],
        } as Record<string, unknown>);
      });

      it("should handle nested wildcard parameters correctly", async () => {
        const parentRouter = new ConcreteRouter();
        const subRouter = new ConcreteRouter();
        const handler = spyWithLength(() => Promise.resolve("ok"));

        subRouter.get("/:name/*{any2}", handler);
        parentRouter.use("/foo/*{any1}", subRouter);

        const req = createMockRequest(
          "GET",
          "http://localhost/foo/123/bar/456/what/how",
        );
        await parentRouter.channelRequestThroughRequestHandlers(
          req,
          createMockResponse(),
        );

        assertEquals(req.params.name, "123");
        assertEquals(req.params.any2, ["bar", "456", "what", "how"]);
        assertEquals(req.params.any1, ["123", "bar", "456", "what", "how"]);
      });
    });

    describe("Error Handling", () => {
      it("should forward primitive values to the next error handler", async () => {
        const router = new ConcreteRouter();
        const errorVal = "something went wrong";
        const handler = spyWithLength(
          (
            _req: GenericRouterRequest,
            _res: RouterResponse,
            next?: RequestHandlerNextFunction,
          ) => {
            next!(errorVal);
            return Promise.resolve();
          },
        );
        const errorHandler = spyWithLength(
          (
            err: unknown,
            _req: GenericRouterRequest,
            _res: RouterResponse,
            _next: RequestHandlerNextFunction,
          ) => {
            assertEquals(err, errorVal);
            return Promise.resolve("handled");
          },
        );

        router.use(handler);
        router.use(errorHandler);

        const result = await router.channelRequestThroughRequestHandlers(
          createMockRequest("GET"),
          createMockResponse(),
        );
        assertEquals(result, "handled");
        assertEquals(handler.calls.length, 1);
        assertEquals(errorHandler.calls.length, 1);
      });

      it("should forward Error objects to the next error handler", async () => {
        const router = new ConcreteRouter();
        const error = new Error("critical error");
        const handler = spyWithLength(
          (
            _req: GenericRouterRequest,
            _res: RouterResponse,
            next?: RequestHandlerNextFunction,
          ) => {
            next!(error);
            return Promise.resolve();
          },
        );
        const errorHandler = spyWithLength(
          (
            err: unknown,
            _req: GenericRouterRequest,
            _res: RouterResponse,
            _next: RequestHandlerNextFunction,
          ) => {
            assertEquals(err, error);
            return Promise.resolve("handled");
          },
        );

        router.use(handler);
        router.use(errorHandler);

        const result = await router.channelRequestThroughRequestHandlers(
          createMockRequest("GET"),
          createMockResponse(),
        );
        assertEquals(result, "handled");
      });

      it("should catch thrown errors and forward them to the next error handler", async () => {
        const router = new ConcreteRouter();
        const error = new Error("thrown error");
        const handler = spyWithLength(() => {
          throw error;
        });
        const errorHandler = spyWithLength(
          (
            err: unknown,
            _req: GenericRouterRequest,
            _res: RouterResponse,
            _next: RequestHandlerNextFunction,
          ) => {
            assertEquals(err, error);
            return Promise.resolve("handled");
          },
        );

        router.use(handler);
        router.use(errorHandler);

        const result = await router.channelRequestThroughRequestHandlers(
          createMockRequest("GET"),
          createMockResponse(),
        );
        assertEquals(result, "handled");
      });
    });

    describe("Return Values", () => {
      it("should return undefined if the handler returns nothing", async () => {
        const router = new ConcreteRouter();
        router.use(
          (
            _req: GenericRouterRequest,
            _res: RouterResponse,
            _next?: RequestHandlerNextFunction,
          ) => {
            return Promise.resolve();
          },
        );

        const result = await router.channelRequestThroughRequestHandlers(
          createMockRequest("GET"),
          createMockResponse(),
        );
        assertEquals(result, undefined);
      });

      it("should return a string if the handler returns a string", async () => {
        const router = new ConcreteRouter();
        router.use(() => Promise.resolve("hello"));

        const result = await router.channelRequestThroughRequestHandlers(
          createMockRequest("GET"),
          createMockResponse(),
        );
        assertEquals(result, "hello");
      });

      it("should return an object if the handler returns an object", async () => {
        const router = new ConcreteRouter();
        const obj = { foo: "bar" };
        router.use(() => Promise.resolve(obj));

        const result = await router.channelRequestThroughRequestHandlers(
          createMockRequest("GET"),
          createMockResponse(),
        );
        assertEquals(result, obj);
      });

      it("should return a RouterResponse if the handler returns one", async () => {
        const router = new ConcreteRouter();
        const res = createMockResponse();
        router.use(() => Promise.resolve(res));

        const result = await router.channelRequestThroughRequestHandlers(
          createMockRequest("GET"),
          createMockResponse(),
        );
        assertEquals(result, res);
      });

      it("should return a Deno Response if the handler returns one", async () => {
        const router = new ConcreteRouter();
        const denoRes = new Response("hi");
        router.use(() => Promise.resolve(denoRes));

        const result = await router.channelRequestThroughRequestHandlers(
          createMockRequest("GET"),
          createMockResponse(),
        );
        assertEquals(result, denoRes);
      });
    });
  });
});
